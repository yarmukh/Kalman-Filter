import numpy as npimport matplotlib.pyplot as pltclass KalmanFilter:    def __init__(self):         self.X = np.array([ [0],                             [0],                             [0],                             [0]])         self.P = np.array([[0, 0, 0, 0],                            [0, 0, 0, 0],                            [0, 0, 0, 0],                            [0, 0, 0, 0]])         self.P[1][1] = 1.e12         self.P[0][0] = 1.e12         self.P[2][2] = 1.e12         self.P[3][3] = 1.e12    def predict(self, dt, std_A):        F = np.array([[1, 0, dt, 0],                      [0, 1, 0, dt],                      [0, 0, 1, 0],                      [0, 0, 0, 1]])        self.X = F @ self.X        Q = F @ F.T * std_A**2        self.P = F @ self.P @ F.T + Q    def update(self, Z, R):        H = np.array([[1, 0, 0, 0],                      [0, 1, 0, 0]])        Y = Z - H @ self.X        S = H @ self.P @ H.T + R        K = self.P @ H.T @ np.linalg.inv(S)        self.X = self.X + K @ Y        self.P = (np.eye(4) - K @ H) @ self.Psize = 100x0 = 0y0 = 12vx = 2vy = 89dt = 3std_x = 1000std_y = 1000Z_arr = []R_arr = []X_arr = []P_arr = []true_arr = []for i in range(size):    true = np.array([[x0 + vx*dt*i],                     [y0 + vy*dt*i]])    Z = np.array([[x0 + vx*dt*i + np.random.normal(0, std_x)],                  [y0 + vy*dt*i + np.random.normal(0, std_y)]])    R = np.array([[std_x**2, 0],                 [0, std_y**2]])    true_arr.append(true)    Z_arr.append(Z)    R_arr.append(R)kf = KalmanFilter()for i in range(size):    kf.predict(dt, 1.)    kf.update(Z_arr[i], R_arr[i])    X_arr.append(kf.X)    P_arr.append(kf.P)x_state_arr = []y_state_arr = []x_meas_arr =[]y_meas_arr = []x_true_arr = []y_true_arr = []error_meas_arr = []error_state_arr = []for _ in range(len(X_arr)):    x_state_arr.append(X_arr[_][0][0])    y_state_arr.append(X_arr[_][1][0])    y_meas_arr.append(Z_arr[_][1][0])    x_meas_arr.append(Z_arr[_][0][0])    x_true_arr.append(true_arr[_][0][0])    y_true_arr.append(true_arr[_][1][0])    error_meas_arr.append(np.sqrt((x_meas_arr[-1] - x_true_arr[-1])**2 + (y_meas_arr[-1] - y_true_arr[-1])**2))    error_state_arr.append(np.sqrt((x_state_arr[-1] - x_true_arr[-1])**2 + (y_state_arr[-1] - y_true_arr[-1])**2))plt.figure()plt.plot(x_true_arr, y_true_arr, marker='.', linestyle='-', color='green', label = 'истина' )plt.plot(x_state_arr, y_state_arr, marker='o', linestyle='-', color='blue', label = 'вектор состояния' )plt.plot(x_meas_arr, y_meas_arr, marker='.', linestyle='-', color='red', label = 'замер' )plt.grid(True)plt.legend()plt.axis('Equal')plt.figure()plt.plot(error_meas_arr, marker='.', linestyle = '-', color = 'red', label = 'ошибка в замера')plt.plot(error_state_arr, marker='.', linestyle = '-', color = 'green', label = 'ошибка в векторе состояния')plt.grid(True)plt.legend()plt.show()print(kf.X)